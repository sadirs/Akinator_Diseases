# -*- coding: utf-8 -*-
"""Akinator_sadi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BT3Zg_hp1K3Cfg407zbyh7G46566hzmg
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.models import load_model

import numpy as np
import pandas as pd
from sklearn.preprocessing import LabelEncoder

class DiseasePredictor:
    def __init__(self, data, model):
        self.data = data
        self.model = model
        self.diseases = data['Disease'].unique()
        self.symptoms = data.columns[1:]
        self.probabilities = {disease: 1/len(self.diseases) for disease in self.diseases}
        self.label_encoder = LabelEncoder()
        self.label_encoder.fit(data['Disease'])
        self.symptom_vector = pd.DataFrame([np.zeros(len(self.symptoms))], columns=self.symptoms)  # Create a vector of zeros

        # Calculate the frequency of each symptom
        self.symptom_frequency = self.data[self.symptoms].sum().sort_values(ascending=False)


    def reset(self):
        """Reset the probabilities and symptom vector to their initial states."""
        self.probabilities = {disease: 1/len(self.diseases) for disease in self.diseases}
        self.symptom_vector = pd.DataFrame([np.zeros(len(self.symptoms))], columns=self.symptoms)
        self.symptom_frequency = self.data[self.symptoms].sum().sort_values(ascending=False)



    def update_probabilities(self, symptom, is_present):
        # Calculate the overall probability of the symptom across all diseases (P(S))
        self.symptom_prob = sum(self.data[self.data['Disease'] == disease][symptom].values[0] * self.probabilities[disease] for disease in self.diseases)

        for disease in self.diseases:
            has_symptom = self.data[self.data['Disease'] == disease][symptom].values[0]
            # Likelihood (P(S|D)): The probability of symptom given the disease
            likelihood = has_symptom if is_present else 1 - has_symptom
            # Prior (P(D)): Current probability of the disease
            prior = self.probabilities[disease]
            # Update the probability using Bayes' Theorem
            if self.symptom_prob > 0:
                self.probabilities[disease] = (likelihood * prior) / self.symptom_prob


        # Normalize probabilities so they sum to 1
        total_prob = sum(self.probabilities.values())
        if total_prob > 0:
          for disease in self.probabilities:
            self.probabilities[disease] /= total_prob


        # update vector
        if is_present:
            self.symptom_vector[symptom] = 1


    def predict(self):
        asked_symptoms = set()

        # Start by asking about the most frequent symptoms
        for symptom in self.symptom_frequency.index:
            if symptom not in asked_symptoms:
                is_present = input(f"Do you have the symptom '{symptom}'? (yes/no): ").strip().lower() == 'yes'
                asked_symptoms.add(symptom)

                if is_present:
                    self.update_probabilities(symptom, is_present)

                    break

        while True:
            # we sort the probabilities
            sorted_probabilities = dict(sorted(self.probabilities.items(), key=lambda item: item[1], reverse=True))

            # we show the 5 highest probabilities
            print(f"\nTop 5 current probabilities (ordered from highest to lowest):")
            for i, (disease, probability) in enumerate(sorted_probabilities.items()):
                if i < 5:
                    print(f"{disease}: {probability:.2%}")
                else:
                    break

            # We identify the disease with the actual highest probaility
            most_likely_disease = max(self.probabilities, key=self.probabilities.get)

            # Find a relevant symptom of this disease that has not yet been asked about
            for symptom in self.symptoms:
                if symptom not in asked_symptoms:
                    if self.data[self.data['Disease'] == most_likely_disease][symptom].values[0] == 1:
                        break

            # ask the user if he has the symptom
            is_present = input(f"Do you have the symptom '{symptom}'? (yes/no): ").strip().lower() == 'yes'
            asked_symptoms.add(symptom)

            # update probabilities
            self.update_probabilities(symptom, is_present)


            # Ask if they want to continue or stop
            if input("Would you like to continue? (yes/no): ").strip().lower() != 'yes':
                break

        # Find the maximum probability value
        max_prob = max(self.probabilities.values())

        # Collect all diseases with the maximum probability
        most_likely_diseases = [disease for disease, prob in self.probabilities.items() if prob == max_prob]

# Display the most likely diseases
        if len(most_likely_diseases) > 1:
          print(f"\nThe most likely diseases based on the given symptoms are: {', '.join(most_likely_diseases)}")




def get_precautions(disease_name, data):
    # Filter the row corresponding to the disease
    disease_row = data[data['Disease'].str.lower() == disease_name.lower()]

    if disease_row.empty:
        return "Disease not found. Please check the spelling or try another disease."

    # Extract the precautions and drop any NaN values
    precautions = disease_row.iloc[0, 1:].dropna().tolist()

    return precautions

# Load the data previously organized
!wget https://raw.githubusercontent.com/sadirs/Akinator_Diseases/main/organized_disease_symptoms.csv
data = pd.read_csv('organized_disease_symptoms.csv')

# Create an instance of the neural network
!wget https://raw.githubusercontent.com/sadirs/Akinator_Diseases/main/Emulator_Disease.keras
model = load_model('Emulator_Disease.keras')
predictor = DiseasePredictor(data, model)


# Create an instance of `DiseasePredictor` with the neural network
!wget https://raw.githubusercontent.com/sadirs/Akinator_Diseases/main/Diseaseprecaution.csv
precautions_data = pd.read_csv('Diseaseprecaution.csv')

# We will use this to de Encode the 'Disease' column from numeric labels
label_encoder = LabelEncoder()
data_encoded = data.copy()
data_encoded['Disease'] = label_encoder.fit_transform(data['Disease'])

predictor.reset()

# start asking
predictor.predict()
new_symptoms=predictor.symptom_vector

# Predict using the model
predicted_probabilities = model.predict(new_symptoms)
predicted_disease_index = predicted_probabilities.argmax()

predicted_disease = label_encoder.inverse_transform([predicted_disease_index])[0]
precautions = get_precautions(predicted_disease, precautions_data)

print(f"Prediction using NN: {predicted_disease}")
#print(f"Predicted Probabilities (NN): {predicted_probabilities}")
print(f"You shoul consider the following tips based on the NN prediction: {precautions}")
predictor.reset()

